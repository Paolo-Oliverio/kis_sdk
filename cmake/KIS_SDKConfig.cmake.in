# cmake/KIS_SDKConfig.cmake.in
@PACKAGE_INIT@

# This config file makes the KIS SDK available to consumer projects.
# It defines an INTERFACE target `KIS_SDK::SDK` that provides the correct,
# platform-aware include paths.

# --- 1. Add our own CMake package directory to the search path ---
# This allows `find_package(kis_core)` etc. to work immediately.
get_filename_component(KIS_SDK_CMAKE_DIR "${CMAKE_CURRENT_LIST_DIR}" ABSOLUTE)
list(PREPEND CMAKE_PREFIX_PATH "${KIS_SDK_CMAKE_DIR}/..")

# --- 2. Load the variant selection system ---
# This must be loaded before any packages are found so that the variant
# selection logic is available.
include("${CMAKE_CURRENT_LIST_DIR}/KIS_SDKVariants.cmake")

# --- 3. Determine Consumer's Platform and Architecture ---
# We must re-run this logic to match the consumer's environment, not the
# environment where the SDK was built.

if(WIN32)
    set(_consumer_platform "windows")
elseif(UNIX AND NOT APPLE AND NOT ANDROID)
    set(_consumer_platform "linux")
elseif(ANDROID)
    set(_consumer_platform "android")
else()
    message(FATAL_ERROR "KIS_SDK: Could not determine consumer platform.")
endif()

if(CMAKE_SYSTEM_PROCESSOR MATCHES "^(x86_64|AMD64)$")
    set(_consumer_arch "x64")
elseif(CMAKE_SYSTEM_PROCESSOR MATCHES "^(aarch64|arm64)$")
    set(_consumer_arch "arm64")
else()
    set(_consumer_arch "${CMAKE_SYSTEM_PROCESSOR}")
endif()

# --- 3.5. Add Platform/ABI-Specific CMake Directories to Search Path ---
# Third-party dependencies (like GLFW) are installed in platform/ABI-specific directories.
# We need to add these to CMAKE_PREFIX_PATH so find_dependency() calls can locate them.
set(_consumer_platform_id "${_consumer_platform}-${_consumer_arch}")

# Add both ABI-invariant and ABI-specific paths to support both types of third-party deps
set(_third_party_cmake_paths "")

# Determine the consumer's build type suffix
set(_consumer_suffix "")
if(CMAKE_BUILD_TYPE)
    string(TOLOWER "${CMAKE_BUILD_TYPE}" _build_type_lower)
    if(_build_type_lower STREQUAL "debug")
        set(_consumer_suffix "-debug")
    elseif(_build_type_lower STREQUAL "release")
        set(_consumer_suffix "-release")
    elseif(_build_type_lower STREQUAL "relwithdebinfo")
        set(_consumer_suffix "-relwithdebinfo")
    elseif(_build_type_lower STREQUAL "minsizerel")
        set(_consumer_suffix "-minsizerel")
    endif()
endif()

# Priority 1: Add the consumer's exact build type path (highest priority)
if(_consumer_suffix)
    set(_abi_specific_cmake_path "${PACKAGE_PREFIX_DIR}/lib/${_consumer_platform_id}${_consumer_suffix}/cmake")
    if(IS_DIRECTORY "${_abi_specific_cmake_path}")
        list(APPEND _third_party_cmake_paths "${_abi_specific_cmake_path}")
    endif()
endif()

# Priority 2: Add ABI-invariant path (e.g., lib/windows-x64/cmake for release builds)
# This is used by third-party deps that don't differentiate between debug/release
set(_abi_invariant_cmake_path "${PACKAGE_PREFIX_DIR}/lib/${_consumer_platform_id}/cmake")
if(IS_DIRECTORY "${_abi_invariant_cmake_path}")
    list(APPEND _third_party_cmake_paths "${_abi_invariant_cmake_path}")
endif()

# Priority 3: Add all other ABI-specific paths as fallbacks
# This ensures compatibility even if the consumer's build type doesn't exactly match
foreach(_suffix IN ITEMS "-debug" "-release" "-relwithdebinfo" "-minsizerel" "-profiling")
    if(NOT _suffix STREQUAL _consumer_suffix)
        set(_fallback_cmake_path "${PACKAGE_PREFIX_DIR}/lib/${_consumer_platform_id}${_suffix}/cmake")
        if(IS_DIRECTORY "${_fallback_cmake_path}")
            list(APPEND _third_party_cmake_paths "${_fallback_cmake_path}")
        endif()
    endif()
endforeach()

# Prepend these paths to CMAKE_PREFIX_PATH so find_dependency() can locate third-party configs
if(_third_party_cmake_paths)
    list(PREPEND CMAKE_PREFIX_PATH ${_third_party_cmake_paths})
    message(STATUS "  --> Third-party CMake search paths: ${_third_party_cmake_paths}")
endif()

# --- 4. Re-create the Platform Tag Hierarchy ---
set(_consumer_tags "")
if(_consumer_platform STREQUAL "windows")
    list(APPEND _consumer_tags "desktop")
elseif(_consumer_platform STREQUAL "linux")
    list(APPEND _consumer_tags "posix" "unix" "desktop")
elseif(_consumer_platform STREQUAL "android")
    list(APPEND _consumer_tags "unix" "mobile")
endif()
list(PREPEND _consumer_tags ${_consumer_platform})
list(REVERSE _consumer_tags) # general -> specific

# --- 5. Construct Ordered, Platform-Aware Search Paths ---
set(KIS_SDK_INCLUDE_DIRS "${PACKAGE_PREFIX_DIR}/include")
set(KIS_SDK_ASSET_DIRS "${PACKAGE_PREFIX_DIR}/assets")

# We loop from most specific to least specific to prepend paths.
list(REVERSE _consumer_tags)
foreach(tag ${_consumer_tags})
    # --- FIX: Point to the new, flatter platform include directory ---
    set(platform_header_path "${PACKAGE_PREFIX_DIR}/platform_include/${tag}")
    if(IS_DIRECTORY "${platform_header_path}")
        list(PREPEND KIS_SDK_INCLUDE_DIRS "${platform_header_path}")
    endif()

    # A VFS can now mount this path and find assets under <package_name>/...
    set(platform_asset_path "${PACKAGE_PREFIX_DIR}/platform_assets/${tag}")
    if(IS_DIRECTORY "${platform_asset_path}")
        list(PREPEND KIS_SDK_ASSET_DIRS "${platform_asset_path}")
    endif()
endforeach()

# Provide an interface target for the whole SDK if needed.
if(NOT TARGET kis::KIS_SDK)
    add_library(kis::KIS_SDK INTERFACE IMPORTED)
    set_target_properties(kis::KIS_SDK PROPERTIES
        INTERFACE_INCLUDE_DIRECTORIES "${KIS_SDK_INCLUDE_DIRS}"
    )
    # Store asset paths for retrieval by a helper function.
    set_property(TARGET kis::KIS_SDK PROPERTY KIS_ASSET_SEARCH_PATHS "${KIS_SDK_ASSET_DIRS}")
endif()

function(kis_sdk_get_asset_paths OUT_VAR)
    get_target_property(${OUT_VAR} kis::KIS_SDK KIS_ASSET_SEARCH_PATHS)
endfunction()

message(STATUS "Found KIS_SDK for ${_consumer_platform}-${_consumer_arch}.")
message(STATUS "  --> Include search order: ${KIS_SDK_INCLUDE_DIRS}")
message(STATUS "  --> Asset search order:   ${KIS_SDK_ASSET_DIRS}")

# Print variant configuration if user has set any overrides
if(DEFINED KIS_SDK_DEFAULT_VARIANT OR DEFINED CMAKE_FIND_PACKAGE_NAME)
    # Defer validation until after all packages are found
    # Users should call kis_sdk_validate_variant_compatibility() after finding all packages
endif()